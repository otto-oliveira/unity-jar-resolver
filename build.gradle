/*
 * Gradle file to build the Jar Resolver Unity plugin.
 */
buildscript {
    repositories {
        mavenCentral()
        mavenLocal()
    }
}

plugins {
    id "com.jetbrains.python.envs" version "0.0.30"
}

/*
 * Project level variables
 */
project.ext {
    // Set of properties to cache in the project.properties file.
    Properties cacheProperties = new Properties()

    // Set of directories to *not* search under the Unity root directory when
    // searching for components of Unity.
    String unitySearchDirExcludesString = findProperty("UNITY_EXCLUDES")
    String[] unitySearchDirExcludes =
            unitySearchDirExcludesString ?
                    unitySearchDirExcludesString.tokenize(";") : []

    // Save the current OS.
    operatingSystem = OperatingSystem.getOperatingSystem()

    // Default installation path for Unity based upon the host operating system.
    List<String> defaultUnityPaths =
            [(OperatingSystem.UNKNOWN): ["Unity"],
             (OperatingSystem.MAC_OSX):
             ["/Applications/Unity/Unity.app/Contents/MacOS/Unity"] +
                     (new FileNameFinder()).getFileNames(
                             "/", "Applications/Unity/Hub/Editor/*/Unity.app/Contents/MacOS/Unity"),
             (OperatingSystem.WINDOWS):
             ["\\Program Files\\Unity\\Editor\\Unity.exe"] +
                     (new FileNameFinder()).getFileNames(
                             "\\", "Program Files\\Unity\\Hub\\Editor\\*\\Editor\\Unity.exe"),
             (OperatingSystem.LINUX)  : ["/opt/Unity/Editor/Unity"]][operatingSystem]

    // Search for the Unity editor executable.
    // The Unity editor is required to package the plug-in.
    for (defaultUnityPath in defaultUnityPaths) {
        unityExe = findFileProperty("UNITY_EXE", new File(defaultUnityPath), false)
        if (unityExe != null && unityExe.exists()) break;
    }
    if (unityExe == null || !unityExe.exists()) {
        unityExe = findFileInPath(unityExe.name)
    }
    if (unityExe == null) {
        throw new StopActionException("Unity editor executable (UNITY_EXE) not " +
                "found")
    }
    saveProperty("UNITY_EXE", unityExe, cacheProperties)

    // Path fragment that is the parent of the unity executable install location.
    // This is used to find the unity root directory from the editor executable.
    String unityExeParentPath =
            [(OperatingSystem.UNKNOWN): "Editor",
             (OperatingSystem.MAC_OSX): "Unity.app/Contents/MacOS",
             (OperatingSystem.WINDOWS): "Editor",
             (OperatingSystem.LINUX)  : "Editor"][operatingSystem]
    File unityRootDir = findFileProperty(
            "UNITY_DIR", new File(unityExe.parentFile.absolutePath -
            unityExeParentPath), true)
    if (unityRootDir == null) {
        throw new StopActionException("Unity root directory (UNITY_DIR) not found.")
    }
    saveProperty("UNITY_DIR", unityRootDir, cacheProperties)

    FileTree unityRootDirTree = fileTree(dir: unityRootDir)

    // Find unity engine dll under the root directory.
    unityDllPath = getFileFromPropertyOrFileTree(
            "UNITY_DLL_PATH", true, {
        unityRootDirTree.matching {
            include "**/Managed/UnityEngine.dll"
            exclude unitySearchDirExcludes
        }
    })
    if (unityDllPath == null) {
        throw new StopActionException(
                "UnityEngine.dll and UnityEditor.dll directory (UNITY_DLL_PATH) " +
                        "not found.")
    }
    saveProperty("UNITY_DLL_PATH", unityDllPath, cacheProperties)

    // iOS runtime dll.  This is with the playback engine, so the
    // structure is different for MacOS and the others.
    unityIosPath = getFileFromPropertyOrFileTree(
            "UNITY_IOS_PLAYBACK_PATH", true, {
        unityRootDirTree.matching {
            include "**/PlaybackEngines/iOSSupport/UnityEditor.iOS.Extensions.dll",
                    "**/PlaybackEngines/iossupport/UnityEditor.iOS.Extensions.dll"
            exclude unitySearchDirExcludes
        }
    })
    if (unityIosPath == null) {
        // iOS support is *required* to build the iOS resolver.
        throw new StopActionException(
                "UnityEditor.iOS.Extensions.dll directory (UNITY_IOS_PLAYBACK_PATH) " +
                        "not found.")
    }
    saveProperty("UNITY_IOS_PLAYBACK_PATH", unityIosPath, cacheProperties)

    // Find xbuild to build the dlls.
    xbuildExe = getFileFromPropertyOrFileTree(
            "XBUILD_EXE", false, {
        unityRootDirTree.matching {
            include(operatingSystem == OperatingSystem.WINDOWS ?
                    "**/bin/xbuild.bat" : "**/xbuild")
            exclude unitySearchDirExcludes
        }
    })
    if (xbuildExe == null) {
        throw new StopActionException("xbuild not found (XBUILD_EXE)")
    }
    saveProperty("XBUILD_EXE", xbuildExe, cacheProperties)

    // Find mono to determine the distribution being used.
    monoExe = getFileFromPropertyOrFileTree(
            "MONO_EXE", false, {
        unityRootDirTree.matching {
            include(operatingSystem == OperatingSystem.WINDOWS ?
                    "**/bin/mono.bat" : "**/bin/mono")
            exclude unitySearchDirExcludes
        }
    })
    saveProperty("MONO_EXE", monoExe, cacheProperties)

    // Get the mono distribution version.
    def versionRegEx = /^.* version ([^ ]+) .*/
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine monoExe, "-V"
        ignoreExitValue true
        standardOutput = stdout
    }
    def monoVersionList =
            stdout.toString().replace("\r\n", "\n").tokenize("\n").findResults {
                def versionMatch = it =~ versionRegEx
                if (versionMatch.matches()) {
                    return versionMatch.group(1)
                }
                return null
            }
    if (!monoVersionList) {
        throw new StopActionException(
                sprintf("Unable to determine mono version from %s", monoExe))
    }
    monoVersion = monoVersionList[0]

    // Mono 5.x and above generate .pdb files that are compatible with visual
    // studio as opposed to the mono-specific .pdb files.
    pdbSupported = monoVersion.tokenize(".")[0].toInteger() >= 5

    if (pdbSupported) {
        logger.warn(
                sprintf("Mono %s detected which will generate .pdb files " +
                        "that are not compatible with older versions of Unity. " +
                        "This can be fixed by compiling with Unity 5.6.",
                        monoVersion))
    }

    // Get the directory that contains this script.
    scriptDirectory = buildscript.sourceFile.getParentFile()

    // It can take a while to search for build tools, so cache paths in the project
    // properties.
    File projectPropertiesFile = new File(scriptDirectory, "gradle.properties")
    if (!projectPropertiesFile.exists()) {
        logger.info(sprintf("Saving %s to %s",
                cacheProperties.stringPropertyNames(),
                projectPropertiesFile))
        cacheProperties.store(projectPropertiesFile.newWriter(), null)
    }

    // UnityAssetUploader required environment variables.
    unityUsername = findProperty("UNITY_USERNAME")
    unityPassword = findProperty("UNITY_PASSWORD")
    unityPackageId = findProperty("UNITY_PACKAGE_ID")
    unityPackagePath = findFileProperty("UNITY_PACKAGE_PATH", null)

    // Whether debug symbols should be included.
    debugEnabled = true

    // Whether interactive mode tests are enabled.
    interactiveModeTestsEnabled =
            findProperty("INTERACTIVE_MODE_TESTS_ENABLED", "1") == "1"

    // Whether to continue to the next test if one fails.
    continueOnFailForTestsEnabled =
            findProperty("CONTINUE_ON_FAIL_FOR_TESTS_ENABLED", "1") == "1"

    // List of test sessions
    testSessions = []

    // List of test types that should be included. Controlled by
    // "INCLUDE_TEST_TYPES" property. Includes every tests if the property is
    // empty.
    // DO NOT USE THIS FOR FILTER, Use `actualIncludeTestTypes` instead.
    includeTestTypesParam =
            TestTypeEnum.toSet(
                    findProperty("INCLUDE_TEST_TYPES", "").split('\\s+|\\s*,\\s*').toList(),
                    true)

    // List of test types that should be excluded. Controlled by
    // "EXCLUDE_TEST_TYPES" property. Excludes none if the property is
    // empty.
    // DO NOT USE THIS FOR FILTER, Use `actualIncludeTestTypes` instead.
    excludeTestTypesParam =
            TestTypeEnum.toSet(
                    findProperty("EXCLUDE_TEST_TYPES", "").split('\\s+|\\s*,\\s*').toList(),
                    false)

    // The actual list of test types to run.
    actualIncludeTestTypes = includeTestTypesParam.clone()
    actualIncludeTestTypes.removeAll(excludeTestTypesParam)

    // List of test modules that should be included. Controlled by
    // "INCLUDE_TEST_MODULES" property. Includes every tests if the property is
    // empty.
    // DO NOT USE THIS FOR FILTER, Use `actualIncludeTestModules` instead.
    includeTestModulesParam =
            TestModuleEnum.toSet(
                    findProperty("INCLUDE_TEST_MODULES", "").split('\\s+|\\s*,\\s*').toList(),
                    true)

    // List of test modules that should be excluded. Controlled by
    // "EXCLUDE_TEST_MODULES" property. Excludes none if the property is
    // empty.
    // DO NOT USE THIS FOR FILTER, Use `actualIncludeTestModules` instead.
    excludeTestModulesParam =
            TestModuleEnum.toSet(
                    findProperty("EXCLUDE_TEST_MODULES", "").split('\\s+|\\s*,\\s*').toList(),
                    false)

    // The actual list of test module to run.
    actualIncludeTestModules = includeTestModulesParam.clone()
    actualIncludeTestModules.removeAll(excludeTestModulesParam)

    // List of tests to exclude. Controlled by "EXCLUDE_TESTS" property. Excludes
    // none if the property is empty.
    excludeTestsParam =
            new HashSet(findProperty("EXCLUDE_TESTS", "").toLowerCase().split('\\s+|\\s*,\\s*').toList())

    // Directory for intermediate and final build outputs.
    buildDir = new File(scriptDirectory, "build")
    // Directory for external tools.
    externalToolsDir = new File(scriptDirectory, "external_tools")
    // Directory for testing.
    testDir = new File(scriptDirectory, "test_output")
    // Version of the plugin (update this with CHANGELOG.md on each release).
    pluginVersion = "1.2.178"
    // Directory that contains the template plugin.
    // Files under this directory are copied into the staging area for the
    // plugin.
    pluginTemplateDir = new File(scriptDirectory, "plugin")
    // Directory where the plugin is staged to be exported as a Unity package.
    pluginStagingAreaDir = new File(buildDir, "staging")
    // Directory where the build plugin is unpacked to.
    pluginExplodedDir = new File(scriptDirectory, "exploded")
    // Directory where the UPM package is unpacked to.
    pluginUpmDir = new File(scriptDirectory, "upm")
    // Base filename of the released plugin.
    currentPluginBasename = "external-dependency-manager"
    // Base UPM package name of the released plugin.
    currentPluginUpmPackageName = "com.google.external-dependency-manager"
    // Where the exported plugin file is built before it's copied to the release
    // location.
    pluginExportFile = new File(buildDir, currentPluginBasename + ".unitypackage")
    // Where the exported UPM plugin file is built.
    pluginUpmExportFile = new File(buildDir,
            currentPluginUpmPackageName + "-" + pluginVersion + ".tgz")
    // Directory within the plugin staging area that just contains the plugin.
    pluginAssetsDir = new File("Assets", "ExternalDependencyManager")
    // Directories within the staging area to export.
    pluginExportDirs = [pluginAssetsDir, new File("Assets", "PlayServicesResolver")]
    // Directory within the plugin directory that contains the managed DLLs.
    pluginEditorDllDir = new File(pluginAssetsDir, "Editor")
    // Directory which contains the solution for all C# projects with a project in
    // each subdirectory.
    pluginSourceDir = new File(scriptDirectory, "source")
    // Solution which references all projects used by the plugin.
    pluginSolutionFile = new File(pluginSourceDir, "ExternalDependencyManager.sln")
    // Versioned release plugin file.
    pluginReleaseFile = new File(scriptDirectory,
            sprintf("%s-%s.unitypackage",
                    currentPluginBasename,
                    pluginVersion))
    // Unversioned release plugin file.
    pluginReleaseFileUnversioned = new File(scriptDirectory,
            sprintf("%s-latest.unitypackage",
                    currentPluginBasename))

    // Location of the Unity asset uploader application.
    unityAssetUploaderDir = new File(pluginSourceDir, "UnityAssetUploader")

    // Location of the export_unity_package application.
    exportUnityPackageDir = new File(pluginSourceDir, "ExportUnityPackage")
    // Location of the import_unity_package application.
    importUnityPackageDir = new File(pluginSourceDir, "ImportUnityPackage")

    // Common arguments used to execute Unity in batch mode.
    unityBatchModeArguments = ["-batchmode", "-nographics"]
    // Common arguments used to execute Unity in interactive mode.
    unityInteractiveModeArguments = ["-gvh_noninteractive"]
    // Extension for Unity asset metadata files.
    unityMetadataExtension = ".meta"
    // Extensions for debug files.
    symbolDatabaseExtension = pdbSupported ? ".pdb" : ".dll.mdb"
    // Changelog file.
    changelog = new File(scriptDirectory, "CHANGELOG.md")
    pythonBootstrapDir = new File(externalToolsDir, "python_bootstrap")
    pythonBinDir = new File(new File(pythonBootstrapDir, "python"), "bin")
    // Python binary after it has been bootstrapped.
    pythonExe = new File(pythonBinDir, "python3")
    // Pip binary after it has been bootstrapped.
    pipExe = new File(pythonBinDir, "pip3")
    // Python packages required by export_unity_package.py
    exportUnityPackageRequirements = ["absl-py", "PyYAML", "packaging"]
    // Python packages required by gen_guids.py
    genGuidRequirements = ["absl-py"]
}

// Configure com.jetbrains.python.envs to bootstrap a Python install.
envs {
    bootstrapDirectory = project.ext.pythonBootstrapDir
    envsDirectory = new File(project.ext.buildDir, "python_envs")
    python "python", "3.9.5"
}

/*
 * Host operating system.
 */

public enum OperatingSystem {
    UNKNOWN, MAC_OSX, WINDOWS, LINUX

    /*
     * Get the current operating system.
     *
     * @returns Current host operating system.
     */

    public static OperatingSystem getOperatingSystem() {
        String os_name = System.getProperty("os.name").toLowerCase()
        if (os_name.contains("mac os x")) {
            return OperatingSystem.MAC_OSX
        } else if (os_name.contains("windows")) {
            return OperatingSystem.WINDOWS
        } else if (os_name.contains("linux")) {
            return OperatingSystem.LINUX
        }
        return OperatingSystem.UNKNOWN
    }
}

/*
 * Test Types
 */

public enum TestTypeEnum {
    INTEGRATION,    // Unity Integration Tests using IntegrationTester framework.
    NUNIT,          // Tests using NUnit framework
    PYTHON,         // Tests implemented in Python
    GRADLE          // Tests implemented in Gradle scripts

    // A complete set of all enums
    private static HashSet<TestTypeEnum> completeSet;

    /*
     * Get a complete set of all enums
     *
     * @returns A complete set of all enums
     */

    private static HashSet<TestTypeEnum> getCompleteSet() {
        if (completeSet == null) {
            completeSet = new HashSet<TestTypeEnum>()
            for (TestTypeEnum type : TestTypeEnum.values()) {
                completeSet.add(type);
            }
        }
        return completeSet.clone()
    }

    /*
     * Convert a list of strings to a set of enums
     *
     * @param values A list of case-insensitive strings to convert to enum.
     * @param completeSetWhenEmpty Whether to return a complete set if the list
     *        is empty.
     *
     * @returns A set of enums
     */

    public static HashSet<TestTypeEnum> toSet(
            Collection<String> values, Boolean completeSetWhenEmpty) {
        def result = new HashSet<TestTypeEnum>()
        if (values == null) {
            return completeSetWhenEmpty ? getCompleteSet() : result;
        }
        for (String value : values) {
            def trimmed = value.trim().toUpperCase()
            if (!trimmed.isEmpty()) {
                result.add(TestTypeEnum.valueOf(trimmed))
            }
        }
        if (result.size() == 0) {
            result = completeSetWhenEmpty ? getCompleteSet() : result;
        }
        return result
    }
}


/*
 * Get a property value by name searching project properties, system properties
 * and environment variables.
 *
 * @param propertyName Name of the property to search for.
 * @param defaultValue Value of the property if it's not found.
 *
 * @returns Property value as string if found and not empty, null otherwise.
 */

String findProperty(String propertyName, String defaultValue = null) {
    Closure valueIsSet = {
        valueString -> valueString != null && !valueString.isEmpty()
    }
    String value = null
    for (def queryObject in [project, System]) {
        if (queryObject.hasProperty(propertyName)) {
            value = queryObject.getProperty(propertyName)
            if (valueIsSet(value)) {
                return value
            }
        }
    }
    value = System.getenv(propertyName)
    return valueIsSet(value) ? value : defaultValue
}

/*
 * Get a property value by name as a file, searching project properties,
 * system properties and environment variables.
 *
 * @param propertyName Name of the property to search for.
 * @param defaultValue Value of the property if it's not found.
 * @param mustExist Whether the file must exist.
 *
 * @returns Property value as a File if found and exists (if mustExist is true),
 *  null otherwise.
 */

File findFileProperty(String propertyName, File defaultValue = null,
                      Boolean mustExist = false) {
    String foundFilePath = findProperty(
            propertyName, defaultValue != null ? defaultValue.absolutePath : null)
    File foundFile = foundFilePath != null ? new File(foundFilePath) : null
    return foundFile != null && (!mustExist || foundFile.exists()) ?
            foundFile : null
}

/*
 * Get a File from the specified property or the shortest path in the specified
 * FileTree object.
 *
 * @param propertyName Property name to lookup prior to searching the tree
 *   for a matching file.
 * @param useParentDirectory If set to true, this returns a File object pointing
 *   at the parent directory of the file that is found.
 * @param fileTreeClosure Closure which returns a FileTree object to search.
 *
 * @return File if it's found and exists, null otherwise.
 */

File getFileFromPropertyOrFileTree(String propertyName,
                                   Boolean useParentDirectory,
                                   fileTreeClosure) {
    File fileValue = findFileProperty(propertyName, null, true)
    if (fileValue == null) {
        // Search for the shortest path to the require file.
        fileTreeClosure().files.each { currentFile ->
            if (fileValue == null ||
                    fileValue.absolutePath.length() > currentFile.absolutePath.length()) {
                fileValue = currentFile
            }
        }
        if (useParentDirectory && fileValue != null) {
            fileValue = fileValue.parentFile
        }
    }
    return fileValue
}

/*
 * Set a project property and log it.
 *
 * @param name Name of the property.
 * @param value Value of the property.
 * @param properties Map of properties to save to.
 */

void saveProperty(String name, value, Properties properties) {
    if (value != null) properties.setProperty(name.toString(), value.toString())
    logger.info(sprintf("%s: %s", name, value))
}

/*
 * Search the path variable for an executable file.
 *
 * @param filename Name of the file to search for.
 *
 * @return If found, the File object that references the file, null otherwise.
 */

File findFileInPath(String filename) {
    def stdout = new ByteArrayOutputStream()
    exec {
        executable OperatingSystem.getOperatingSystem() == OperatingSystem.WINDOWS ?
                "where" : "which"
        args filename
        ignoreExitValue true
        standardOutput = stdout
    }
    String resultString = stdout.toString()
    return resultString.isEmpty() ? null : new File(resultString)
}


task cleanTests(type: Delete) {
    description "Clean test directories."
    delete project.ext.testDir
}

task cleanAll(type: Delete) {
    description "Clean the build directory."
    delete project.ext.buildDir
}

project.defaultTasks = ["build", "test", "release", "clean"].collect {
    topLevelTaskName ->
        tasks.create(name: topLevelTaskName,
                description: sprintf("Run all %s tasks",
                        topLevelTaskName),
                type: Task,
                dependsOn: project.tasks.findAll {
                    task -> task.name.startsWith(topLevelTaskName)
                })
}

// Disable tests by filters.
project.tasks.findAll { task ->
    if (task.hasProperty("testType") && task.testType != null &&
            task.hasProperty("testModule") && task.testModule != null) {
        if (!shouldTestRunWithFilters(task.testType, task.testModule)) {
            println sprintf("DISABLED :%s", task.name)
            task.enabled = false
        }
        if (project.ext.excludeTestsParam.contains(task.name.toLowerCase())) {
            println sprintf("DISABLED :%s", task.name)
            task.enabled = false
        }
    }
}
